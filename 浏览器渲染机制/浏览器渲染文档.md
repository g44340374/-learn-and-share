---
---

#### 浏览器渲染页面的机制和原理

​ 进程 Process 线程 Thread 栈内存 Stack

​ 操作系统(Mac、Linux、window)，都是支持'多任务'的操作系统

​ 单核 CUP 执行多任务：操作系统轮流让各个任务交替执行，任务 1(打游戏)执行 0.01s，切换到任务 2(听音乐)，再执行 0.01s，再切换到任务 3...由于 CUP 执行速度太快，给用户的感觉就像所有任务统一执行。

​ 多核 CPU 执行多任务:真正的并行执行多任务只能在多核 CPU 上面实现，但是由于任务数量远远多于 CPU 核心数量，所以，操作系统也会把很多任务轮流调度到每个核心上运行

​ 有些进程还不止同时干一件事情，同时做很多事情，就需要同时运行多个子任务，进程内的子任务就称之为线程

​ 多个线程可以同时运行，多线程的执行方式和多进程是一样的，由于操作系统在多个线程之间快速切换，每个线程短暂交替运行，看起来就像同时执行一样

#### 客户端(浏览器)和服务器端(Web 服务器)

1. 浏览器向服务器端发送请求

   request 请求阶段：DNS 解析、TCP 协议的三次握手和四次挥手、HTTPS 和 HTTP、HTTP2 的区别

   ##### DNS 解析：

   ```javascript
   // 首先 我们要理解域名和ip地址就相当于一个对象
   {
       ipv4:'100.100.100.100',
       ipv6:'2020:1010::6822:1235',
       name:'百度',
       type:'www.baidu.com'
   }
   1、通过域名获取解析器ip地址
   2、DNS缓存：  浏览器缓存：是否访问过这个地址。

   			操作系统：分级查询： hosts文件 ，本地DNS服务器、根域名服务器、COm顶级域名								服务器、	google.com域名服务器
   ```

   ##### TCP 链接(三次握手)

   ```
    // 三次握手
    // TCP报文段的字段和标志位
    标志位
    ACK 确认字段中的值是有效的，SYN用于连接建立，FIN用于连接拆除
    ACK = 1 有效
    ACK = 0 无效
    SYN = 1 表明是一个请求连接报文
    FIN = 1 表明发送方数据已发送完毕，并要求释放连接
   客户端 -> 服务端 // SYN = 1(请求建立链接), seq=n(序列号)
   服务端 -> 客户端 // SYN = 1(同意建立链接)，ack = n+1(确认收到消息), seq = x(服务端序列号)
   客户端 -> 服务端 // SYN = 0 (开始发送信息), ack = x+1(确认)， seq = n+1

   1、 客户端具有发送消息的能力
   2、 服务端具有接收信息和发送信息的能力
   3、 客户端具有接受信息的能力
   丢包问题、乱序问题

   TCP建立一个缓冲区
   发送缓冲： 1、2、3、4、5、6、7....N
   发送报文： 序列号 长度 数据内容
   回复确认： ACK = 序列号+长度 = 下一包起始序列号
   切割发送： 根据序列号和长度重组、 丢失重发
   ```

   四次挥手

   ```
   第一次挥手：客户端发送 fin包告诉服务端我要关闭连接、并进入终止等待1状态
   第二次： 服务端接受到fin包发送给客户端ack包， 表示自己进入了关闭等待状态，客户端进入终止等待2状态，服务端可以发送未发送的数据、客户端还可以接受数据
   第三次： 服务端发送fin包到客户端、进入终止等待状态
   第四次： 客户端发送ack包到服务端、服务端接受到ack包之后立马关闭。客户端进入超时等待状态、超时完进行关闭
   ```

   ##### HTTP、HTTP2、HTTPS 区别

   ###### // HTTP/0.9

   没有 http 头、没有状态码，甚至连版本号都没有，支持一种方法 get，请求只有一行，相应也非常简单，只包含 html 本身
   当 TCP 建立连接之后，服务器向客户端返回 HTML 格式的字符串。发送完毕关闭 TCP 连接。由于没有状态码和错误代码，如果服务器处理时候发生错误，指挥传回一个特殊的包含问题描述信息的 HTML 文件

   ###### // HTTP/1.0:

   浏览器与服务器保持短暂的连接，每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，
   每次与服务器交互，都需要重新开一个连接

   ```
   		建立连接   数据传输     关闭连接
   客户端 <--------------------------------------------> 服务端
   		建立连接   数据传输     关闭连接
   客户端 <---------------------------------------------> 服务端
   		建立连接   数据传输     关闭连接
   客户端 <----------------------------------------------> 服务端
   ```

   解析 html 文件的时候，发现 html 中存在 css 包、js 包等资源文件的时候，这时候就又创建一种单独链接，导致了一个 html 中访问多次请求和相应，每次都需要创建链接、关系链接，有很明显的性能缺陷

   ###### // HTTP/1.1：使用最广泛的是 1.1 版本

   为了解决 1.0 导致的性能缺陷

   ```
   在请求头里面加了connection：keep-alive
   				建立连接
   				多次数据传输
   客户端 <---------------------------------> 服务端
   				关闭连接

   请求是有上线的，如果连接过多，并不影响性能，会导致浏览器负载过度，所以有一个权衡。chrome：6-8个
   ```

   这样加载 html 文件的时候，文件中多个请求和响应就可以在连接中传输，减少了性能的浪费

   http1.1 还允许客户端**不用等待上一次请求结果返回**，就可以发出**下一个请求**，但是服务器必须按照接收到客户端请求的先后顺序依次会送**响应结果**，保证客户端能够区分出每次请求的响应内容，这样也显著的减少了整个下载过程所需要的时间。

   http1 导致的一些问题

   1、明文传输

   2、传输问题：乱入块传递，把一个文件分成好多块，假如第三块请求失败，需要响应第三块。

   3、header 太长

   4、server 端无法进行主动 push ：websocket 使服务端主动进行 push

   ###### http2

   多路复用、二进制分帧、首部压缩、服务器推送

   多路复用：复用 TCP 链接，在一个连接里，客户端和浏览器都可以同时发送多个请求或响应，而且不用按照顺序一一对应，这样就避免了阻塞现象

   ```
   1、 建立TCP链接

   			get/index.html
   2、客户端 ------------>服务端

   		response
   3、服务端-------------->客户端

   4、
   			css
   客户端  ===================> 服务端
    			script

   			css
   客户端  <=================== 服务端
    			script

    5、四次挥手断开链接
   ```

   二进制分帧：把明文压缩成二进制

   把 1.1 版本的块打成帧

   单链接 + 帧

   ###### https（s => ssl/tls）

   1、https 需要 ca 请求证书

   2、明文加密

   3、连接方式，端口号不同 443 80

   4、防止运行商劫持

2. 服务器端响应浏览器资源（源代码）

   response 响应阶段: HTTP 状态码、304 缓存、HTTP 报文

   状态码

   1xx(临时响应)：表示临时响应并需要请求者继续执行操作的状态码

   ```
   100     //继续  请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
   101     //切换协议  请求者已要求服务器切换协议，服务器已确认并准备切换。
   ```

   2xx(成功)

   ```
   200     //成功  服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页。
   201     //已创建  请求成功并且服务器创建了新的资源
   202     //已接受  服务器已接受请求，但尚未处理
   203     //非授权信息  服务器已经成功处理了请求，但返回的信息可能来自另一来源
   204     //无内容  服务器成功处理了请求，但没有返回任何内容
   205     //重置内容  服务器成功处理了请求，但没有返回任何内容
   206     //部分内容  服务器成功处理了部分GET请求

   作者：屁屁与猪猪
   链接：https://juejin.cn/post/6844903459129425934
   来源：稀土掘金
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
   ```

   3xx(重定向) 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。

   ```
   300     //多种选择  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。
   301     //永久移动  请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置。
   302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
   303     //查看其它位置  请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码
   304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容
   305     //使用代理  请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
   307     //临时性重定向  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求
   ```

   4xx(请求错误) 请求出错，妨碍服务器处理

   ```
   400     //错误请求  服务器不理解请求的语法
   401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
   403     //禁止  服务器拒绝请求
   404     //未找到  服务器找不到请求的网页
   405     //方法禁用  禁用请求中指定的方法
   406     //不接受  无法使用请求的内容特性响应请求的网页
   407     //需要代理授权  此状态码与401（未授权）类似，但指定请求者应当授权使用代理
   408     //请求超时  服务器等候请求时发生超时
   409     //冲突  服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。
   410     //已删除  如果请求的资源已永久删除，服务器就会返回此响应
   411     //需要有效长度  服务器不接受不含有效内容长度标头字段的请求
   412     //未满足前提条件  服务器未满足请求者在请求者设置的其中一个前提条件
   413     //请求实体过大  服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力
   414     //请求的URI过长  请求的URI（通常为网址）过长，服务器无法处理
   415     //不支持媒体类型  请求的格式不受请求页面的支持
   416     //请求范围不符合要求  如果页面无法提供请求的范围，则服务器会返回此状态码
   417     //未满足期望值  服务器未满足“期望”请求标头字段的要求
   ```

   5xx(服务器错误)：状态码表示服务器尝试处理请求时发生内部错误，可能是服务器本身的错误

   ```
   500     //服务器内部错误  服务器遇到错误，无法完成请求
   501     //尚未实施  服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
   502     //错误网关  服务器作为网关或代理，从上游服务器无法收到无效响应
   503     //服务器不可用  服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
   504     //网关超时  服务器作为网关代理，但是没有及时从上游服务器收到请求
   505     //HTTP版本不受支持  服务器不支持请求中所用的HTTP协议版本

   作者：屁屁与猪猪
   链接：https://juejin.cn/post/6844903459129425934
   来源：稀土掘金
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
   ```

   http 分为：请求报文、响应报文

   请求报文

   ```
   请求行：方法 url 版本 回车符 换行符

   		get 地址 http1

   请求头部
   首部：域值回车符换行符
   ...多个首部与域值...

   请求数据
   实体
   ```

   响应报文

   ```
   状态行 版本 状态码 原因短句

   header行 首部：域值 回车 换行

   实体： 实体
   ```

3. 拿到代码后：浏览器在内存条中开辟一块栈内存，用来给代码的执行提供环境；同时分配一个主线程去运行一行行的解析和执行代码

   进栈执行 ：代码进入环境里面执行代码，执行完之后出栈。一行行代码执行，代码进栈-出栈循环

   ###### Event Loop

   当浏览器遇到'link/script/img/video 等请求后'，都会单独开辟新的线程(TASK QUEUE)任务队列，

   第一次自上而下代码执行完毕之后，只生成 DOM 树，然后去任务队列里面加载完成的外部资源，CSS 处理完生成 CSSOM，加载完成之后，DOM 和 CSSOM 会结合成 Render Tree 渲染树

   Layout(回流)，根据生成的渲染树，计算它们在设备视口(viewport

   )内确切的位置和大小，计算的阶段就是回流，然后根据回流得到的几何信息，得到节点的绝对元素，称之为重绘(Painting)，将像素发给 GPU 展现在页面上(Dispay)

   补充：

   ​ 性能优化：

   ​ 1、减少 HTTP 的请求次数和大小

   ​ 1-1 资源合并压缩

   ​ 1-2 图片懒加载

   ​ 1-3 音视频走流文建(只加载一部分就能渲染：直播：m3u8)

#### DOM 的重绘和回流 Repaint & Reflow

​ 重绘：元素样式的改变(宽高、大小、位置不变)

[^]: visibility、color、background 等

​ 回流：元素的大小或位置发生变化(当页面布局和几何信息发生变化时)，触发重新布局，导致渲染树重新计算布局和渲染

[^]: 添加或者删除可见的 DOM 元素；元素位置发生变化；元素尺寸发生变化，内容发生变化(图片被另一个图片替代)；页面开始渲染的时候；因为回流是根据视口的大小计算元素的位置和大小，所以浏览器窗口尺寸变化也会引发回流

###### 避免 DOM 的回流(前端优化)

1. ​ 放弃传统操作 dom，基于 vue/react 开始数据影响视图模式

   [^]: mvvm/mvc/dom diff/virtual dom

2. 分离读写操作

   分离读写：box.style.width = '200px'

   ​ box.style.height= '200px'

   ​ console.log(box.clientWidth)

   批量处理：box.style.cssText = 'windth:200px'

   ​ box.className = 'aa'

   缓存处理：box.style.width = box.clientWidth + 10 + 'px'

   ​ box.style.height= box.clientHetght + 10 + 'px'

3. 样式集中改变

4. 动画效果应用到 position：absolute||fixed 元素上(脱离文档流)

5. css3 硬件加速(GPU 加速)

   [^]: 比起如何减少回流重绘，更好的方案是不要回流重绘：transform\ opacity 等这些属性会触发硬件加速，不会引发回流和重绘

   [^]: 可能会引起的问题：过多使用占用大量内存、性能消耗严重，字体模糊等

6. 牺牲平滑度换取速度

   [^]: 每次 1 像素移动一个动画，但如果此动画使用了 100%的 CPU，动画看上去是跳动的，因为浏览器正在与更新回流做斗争，每次移动 3 像素看起来平滑度低了，但它不会导致 CPU 在较慢的机器中抖动

7. 避免在 table 布局和使用 css 的 javascript 表达式

   [^]: table 不好写样式，不利于 dom 的性能优化

​
