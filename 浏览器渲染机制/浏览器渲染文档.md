---

---

#### 浏览器渲染页面的机制和原理

​	进程  Process        线程Thread              栈内存Stack

​	操作系统(Mac、Linux、window)，都是支持'多任务'的操作系统

​	单核CUP执行多任务：操作系统轮流让各个任务交替执行，任务1(打游戏)执行0.01s，切换到任务2(听音乐)，再执行0.01s，再切换到任务3...由于CUP执行速度太快，给用户的感觉就像所有任务统一执行。

​	多核CPU执行多任务:真正的并行执行多任务只能在多核CPU上面实现，但是由于任务数量远远多于CPU核心数量，所以，操作系统也会把很多任务轮流调度到每个核心上运行

​	有些进程还不止同时干一件事情，同时做很多事情，就需要同时运行多个子任务，进程内的子任务就称之为线程

​	多个线程可以同时运行，多线程的执行方式和多进程是一样的，由于操作系统在多个线程之间快速切换，每个线程短暂交替运行，看起来就像同时执行一样

#### 客户端(浏览器)和服务器端(Web服务器)

1. 浏览器向服务器端发送请求

   request请求阶段：DNS解析、TCP协议的三次握手和四次挥手、HTTPS和HTTP、HTTP2的区别

2. 服务器端响应浏览器资源（源代码）

   response响应阶段: HTTP状态码、304缓存、HTTP报文

3.  拿到代码后：浏览器在内存条中开辟一块栈内存，用来给代码的执行提供环境；同时分配一个主线程去运行一行行的解析和执行代码

   进栈执行 ：代码进入环境里面执行代码，执行完之后出栈。一行行代码执行，代码进栈-出栈循环

   ###### Event Loop

   当浏览器遇到'link/script/img/video等请求后'，都会单独开辟新的线程(TASK QUEUE)任务队列，

   第一次自上而下代码执行完毕之后，只生成DOM树，然后去任务队列里面加载完成的外部资源，CSS处理完生成CSSOM，加载完成之后，DOM和CSSOM会结合成Render Tree渲染树

   Layout(回流)，根据生成的渲染树，计算它们在设备视口(viewport

   )内确切的位置和大小，计算的阶段就是回流，然后根据回流得到的几何信息，得到节点的绝对元素，称之为重绘(Painting)，将像素发给GPU展现在页面上(Dispay)

   补充：

   ​	性能优化：

   ​		1、减少HTTP的请求次数和大小

   ​			1-1资源合并压缩

   ​			1-2图片懒加载

   ​			1-3音视频走流文建(只加载一部分就能渲染：直播：m3u8)

#### DOM的重绘和回流 Repaint & Reflow

​	重绘：元素样式的改变(宽高、大小、位置不变)

[^]: visibility、color、background等

​	回流：元素的大小或位置发生变化(当页面布局和几何信息发生变化时)，触发重新布局，导致渲染树重新计算布局和渲染

[^]: 添加或者删除可见的DOM元素；元素位置发生变化；元素尺寸发生变化，内容发生变化(图片被另一个图片替代)；页面开始渲染的时候；因为回流是根据视口的大小计算元素的位置和大小，所以浏览器窗口尺寸变化也会引发回流

###### 	避免DOM的回流(前端优化)

1. ​	放弃传统操作dom，基于vue/react开始数据影响视图模式

   [^]: mvvm/mvc/dom diff/virtual dom

2. 分离读写操作

   分离读写：box.style.width = '200px'

   ​                   box.style.height= '200px'

   ​                   console.log(box.clientWidth)

   批量处理：box.style.cssText = 'windth:200px'

   ​					box.className = 'aa'

   缓存处理：box.style.width = box.clientWidth + 10 + 'px'

   ​					box.style.height= box.clientHetght + 10 + 'px'

3. 样式集中改变

4. 动画效果应用到position：absolute||fixed元素上(脱离文档流)

5. css3硬件加速(GPU加速)

   [^]: 比起如何减少回流重绘，更好的方案是不要回流重绘：transform\ opacity等这些属性会触发硬件加速，不会引发回流和重绘
   [^]: 可能会引起的问题：过多使用占用大量内存、性能消耗严重，字体模糊等

6. 牺牲平滑度换取速度

   [^]: 每次1像素移动一个动画，但如果此动画使用了100%的CPU，动画看上去是跳动的，因为浏览器正在与更新回流做斗争，每次移动3像素看起来平滑度低了，但它不会导致CPU在较慢的机器中抖动

7. 避免在table布局和使用css的javascript表达式

   [^]: table不好写样式，不利于dom的性能优化

   

​	

