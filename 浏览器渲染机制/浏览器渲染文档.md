---

---

#### 浏览器渲染页面的机制和原理

​	进程  Process        线程Thread              栈内存Stack

​	操作系统(Mac、Linux、window)，都是支持'多任务'的操作系统

​	单核CUP执行多任务：操作系统轮流让各个任务交替执行，任务1(打游戏)执行0.01s，切换到任务2(听音乐)，再执行0.01s，再切换到任务3...由于CUP执行速度太快，给用户的感觉就像所有任务统一执行。

​	多核CPU执行多任务:真正的并行执行多任务只能在多核CPU上面实现，但是由于任务数量远远多于CPU核心数量，所以，操作系统也会把很多任务轮流调度到每个核心上运行

​	有些进程还不止同时干一件事情，同时做很多事情，就需要同时运行多个子任务，进程内的子任务就称之为线程

​	多个线程可以同时运行，多线程的执行方式和多进程是一样的，由于操作系统在多个线程之间快速切换，每个线程短暂交替运行，看起来就像同时执行一样

#### 客户端(浏览器)和服务器端(Web服务器)

1. 浏览器向服务器端发送请求

   request请求阶段：DNS解析、TCP协议的三次握手和四次挥手、HTTPS和HTTP、HTTP2的区别

   ##### DNS解析：

   ```javascript
   // 首先 我们要理解域名和ip地址就相当于一个对象
   {
       ipv4:'100.100.100.100',
       ipv6:'2020:1010::6822:1235',
       name:'百度',
       type:'www.baidu.com'
   }
   1、通过域名获取解析器ip地址
   2、DNS缓存：  浏览器缓存：是否访问过这个地址。
   			
   			操作系统：分级查询： hosts文件 ，本地DNS服务器、根域名服务器、COm顶级域名								服务器、	google.com域名服务器
   ```

   ##### TCP链接(三次握手)

   ```
    // 三次握手
    // TCP报文段的字段和标志位
    标志位
    ACK 确认字段中的值是有效的，SYN用于连接建立，FIN用于连接拆除
    ACK = 1 有效 
    ACK = 0 无效 
    SYN = 1 表明是一个请求连接报文
    FIN = 1 表明发送方数据已发送完毕，并要求释放连接
   客户端 -> 服务端 // SYN = 1(请求建立链接), seq=n(序列号)  
   服务端 -> 客户端 // SYN = 1(同意建立链接)，ack = n+1(确认收到消息), seq = x(服务端序列号)
   客户端 -> 服务端 // SYN = 0 (开始发送信息), ack = x+1(确认)， seq = n+1
   
   1、 客户端具有发送消息的能力
   2、 服务端具有接收信息和发送信息的能力
   3、 客户端具有接受信息的能力
   丢包问题、乱序问题
   
   TCP建立一个缓冲区
   发送缓冲： 1、2、3、4、5、6、7....N
   发送报文： 序列号 长度 数据内容
   回复确认： ACK = 序列号+长度 = 下一包起始序列号
   切割发送： 根据序列号和长度重组、 丢失重发
   ```

   四次挥手

   ```
   第一次挥手：客户端发送 fin包告诉服务端我要关闭连接、并进入终止等待1状态
   第二次： 服务端接受到fin包发送给客户端ack包， 表示自己进入了关闭等待状态，客户端进入终止等待2状态，服务端可以发送未发送的数据、客户端还可以接受数据
   第三次： 服务端发送fin包到客户端、进入终止等待状态
   第四次： 客户端发送ack包到服务端、服务端接受到ack包之后立马关闭。客户端进入超时等待状态、超时完进行关闭
   ```

   ##### HTTP、HTTP2、HTTPS区别

   ###### // HTTP/0.9

   没有http头、没有状态码，甚至连版本号都没有，支持一种方法get，请求只有一行，相应也非常简单，只包含html本身
   当TCP建立连接之后，服务器向客户端返回HTML格式的字符串。发送完毕关闭TCP连接。由于没有状态码和错误代码，如果服务器处理时候发生错误，指挥传回一个特殊的包含问题描述信息的HTML文件

   ###### // HTTP/1.0: 

   浏览器与服务器保持短暂的连接，每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，
   每次与服务器交互，都需要重新开一个连接

   ```
   		建立连接   数据传输     关闭连接
   客户端 <--------------------------------------------> 服务端
   		建立连接   数据传输     关闭连接
   客户端 <---------------------------------------------> 服务端
   		建立连接   数据传输     关闭连接
   客户端 <----------------------------------------------> 服务端
   ```

   解析html文件的时候，发现html中存在css包、js包等资源文件的时候，这时候就又创建一种单独链接，导致了一个html中访问多次请求和相应，每次都需要创建链接、关系链接，有很明显的性能缺陷

   ###### // HTTP/1.1：使用最广泛的是1.1版本

   为了解决1.0导致的性能缺陷

   ```
   				建立连接
   				多次数据传输
   客户端 <---------------------------------> 服务端
   				关闭连接
   ```

   这样加载html文件的时候，文件中多个请求和响应就可以在连接中传输，减少了性能的浪费

   http1.1还允许客户端**不用等待上一次请求结果返回**，就可以发出**下一个请求**，但是服务器必须按照接收到客户端请求的先后顺序依次会送**响应结果**，保证客户端能够区分出每次请求的响应内容，这样也显著的减少了整个下载过程所需要的时间。

   在1.0的基础上增加了更多的请求头和响应头来完善功能

   

   ###### http2

   多路复用、二进制分帧、首部压缩、服务器推送

   

   多路复用：复用TCP链接，在一个连接里，客户端和浏览器都可以同时发送多个请求或响应，而且不用按照顺序一一对应，这样就避免了阻塞现象

   ```
   1、 建立TCP链接
   
   			get/index.html
   2、客户端 ------------>服务端
   
   		response
   3、服务端-------------->客户端
   
   4、
   			css
   客户端  ===================> 服务端
    			script
    			
   			css
   客户端  <=================== 服务端
    			script
    			
    5、四次挥手断开链接
   ```

   

   二进制分帧

   帧是HTTP2通信中最小单位信息

   

   首部压缩：

   

   

2. 服务器端响应浏览器资源（源代码）

   response响应阶段: HTTP状态码、304缓存、HTTP报文

3.  拿到代码后：浏览器在内存条中开辟一块栈内存，用来给代码的执行提供环境；同时分配一个主线程去运行一行行的解析和执行代码

   进栈执行 ：代码进入环境里面执行代码，执行完之后出栈。一行行代码执行，代码进栈-出栈循环

   ###### Event Loop

   当浏览器遇到'link/script/img/video等请求后'，都会单独开辟新的线程(TASK QUEUE)任务队列，

   第一次自上而下代码执行完毕之后，只生成DOM树，然后去任务队列里面加载完成的外部资源，CSS处理完生成CSSOM，加载完成之后，DOM和CSSOM会结合成Render Tree渲染树

   Layout(回流)，根据生成的渲染树，计算它们在设备视口(viewport

   )内确切的位置和大小，计算的阶段就是回流，然后根据回流得到的几何信息，得到节点的绝对元素，称之为重绘(Painting)，将像素发给GPU展现在页面上(Dispay)

   补充：

   ​	性能优化：

   ​		1、减少HTTP的请求次数和大小

   ​			1-1资源合并压缩

   ​			1-2图片懒加载

   ​			1-3音视频走流文建(只加载一部分就能渲染：直播：m3u8)

#### DOM的重绘和回流 Repaint & Reflow

​	重绘：元素样式的改变(宽高、大小、位置不变)

[^]: visibility、color、background等

​	回流：元素的大小或位置发生变化(当页面布局和几何信息发生变化时)，触发重新布局，导致渲染树重新计算布局和渲染

[^]: 添加或者删除可见的DOM元素；元素位置发生变化；元素尺寸发生变化，内容发生变化(图片被另一个图片替代)；页面开始渲染的时候；因为回流是根据视口的大小计算元素的位置和大小，所以浏览器窗口尺寸变化也会引发回流

###### 	避免DOM的回流(前端优化)

1. ​	放弃传统操作dom，基于vue/react开始数据影响视图模式

   [^]: mvvm/mvc/dom diff/virtual dom

2. 分离读写操作

   分离读写：box.style.width = '200px'

   ​                   box.style.height= '200px'

   ​                   console.log(box.clientWidth)

   批量处理：box.style.cssText = 'windth:200px'

   ​					box.className = 'aa'

   缓存处理：box.style.width = box.clientWidth + 10 + 'px'

   ​					box.style.height= box.clientHetght + 10 + 'px'

3. 样式集中改变

4. 动画效果应用到position：absolute||fixed元素上(脱离文档流)

5. css3硬件加速(GPU加速)

   [^]: 比起如何减少回流重绘，更好的方案是不要回流重绘：transform\ opacity等这些属性会触发硬件加速，不会引发回流和重绘
   [^]: 可能会引起的问题：过多使用占用大量内存、性能消耗严重，字体模糊等

6. 牺牲平滑度换取速度

   [^]: 每次1像素移动一个动画，但如果此动画使用了100%的CPU，动画看上去是跳动的，因为浏览器正在与更新回流做斗争，每次移动3像素看起来平滑度低了，但它不会导致CPU在较慢的机器中抖动

7. 避免在table布局和使用css的javascript表达式

   [^]: table不好写样式，不利于dom的性能优化

   

​	

